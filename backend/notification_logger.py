"""
Notification and Logging System
Comprehensive notification and logging system for stock screening pipeline
"""

import logging
import smtplib
import requests
import json
import os
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.mime.base import MIMEBase
from email import encoders
import pandas as pd
from sqlalchemy import create_engine, text
from dotenv import load_dotenv
import traceback
from pathlib import Path

# Load environment variables
load_dotenv()

class NotificationLogger:
    """
    Comprehensive notification and logging system
    """
    
    def __init__(self, db_engine=None):
        """Initialize the notification and logging system"""
        self.db_engine = db_engine
        if db_engine is None and os.getenv("DATABASE_URL"):
            self.db_engine = create_engine(os.getenv("DATABASE_URL"))
        
        # Configuration
        self.config = {
            # Email configuration
            'smtp_server': os.getenv('SMTP_SERVER', 'smtp.gmail.com'),
            'smtp_port': int(os.getenv('SMTP_PORT', '587')),
            'smtp_username': os.getenv('SMTP_USERNAME'),
            'smtp_password': os.getenv('SMTP_PASSWORD'),
            'notification_email': os.getenv('NOTIFICATION_EMAIL'),
            'admin_email': os.getenv('ADMIN_EMAIL'),
            
            # Slack configuration
            'slack_webhook': os.getenv('SLACK_WEBHOOK'),
            'slack_channel': os.getenv('SLACK_CHANNEL', '#stock-alerts'),
            'slack_username': os.getenv('SLACK_USERNAME', 'StockPulse Bot'),
            
            # Discord configuration
            'discord_webhook': os.getenv('DISCORD_WEBHOOK'),
            'discord_username': os.getenv('DISCORD_USERNAME', 'StockPulse Bot'),
            
            # Telegram configuration
            'telegram_bot_token': os.getenv('TELEGRAM_BOT_TOKEN'),\n            'telegram_chat_id': os.getenv('TELEGRAM_CHAT_ID'),\n            \n            # Logging configuration\n            'log_level': os.getenv('LOG_LEVEL', 'INFO'),\n            'log_file': os.getenv('LOG_FILE', 'stockpulse.log'),\n            'max_log_size': int(os.getenv('MAX_LOG_SIZE', '50')),  # MB\n            'log_retention_days': int(os.getenv('LOG_RETENTION_DAYS', '30'))\n        }\n        \n        # Setup logging\n        self._setup_logging()\n        \n        # Notification history\n        self.notification_history = []\n    \n    def _setup_logging(self):\n        \"\"\"Setup comprehensive logging configuration\"\"\"\n        # Create logs directory\n        log_dir = Path('logs')\n        log_dir.mkdir(exist_ok=True)\n        \n        # Setup rotating file handler\n        from logging.handlers import RotatingFileHandler\n        \n        # Main application logger\n        self.logger = logging.getLogger('stockpulse')\n        self.logger.setLevel(getattr(logging, self.config['log_level']))\n        \n        # Remove existing handlers\n        self.logger.handlers.clear()\n        \n        # File handler with rotation\n        file_handler = RotatingFileHandler(\n            log_dir / self.config['log_file'],\n            maxBytes=self.config['max_log_size'] * 1024 * 1024,\n            backupCount=5\n        )\n        \n        # Console handler\n        console_handler = logging.StreamHandler()\n        \n        # Formatters\n        detailed_formatter = logging.Formatter(\n            '%(asctime)s - %(name)s - %(levelname)s - %(funcName)s:%(lineno)d - %(message)s'\n        )\n        \n        simple_formatter = logging.Formatter(\n            '%(asctime)s - %(levelname)s - %(message)s'\n        )\n        \n        file_handler.setFormatter(detailed_formatter)\n        console_handler.setFormatter(simple_formatter)\n        \n        self.logger.addHandler(file_handler)\n        self.logger.addHandler(console_handler)\n        \n        # Setup specialized loggers\n        self._setup_specialized_loggers(log_dir)\n    \n    def _setup_specialized_loggers(self, log_dir: Path):\n        \"\"\"Setup specialized loggers for different components\"\"\"\n        from logging.handlers import RotatingFileHandler\n        \n        # Screening results logger\n        self.screening_logger = logging.getLogger('stockpulse.screening')\n        self.screening_logger.setLevel(logging.INFO)\n        screening_handler = RotatingFileHandler(\n            log_dir / 'screening_results.log',\n            maxBytes=10 * 1024 * 1024,\n            backupCount=10\n        )\n        screening_handler.setFormatter(logging.Formatter(\n            '%(asctime)s - %(message)s'\n        ))\n        self.screening_logger.addHandler(screening_handler)\n        \n        # Signals logger\n        self.signals_logger = logging.getLogger('stockpulse.signals')\n        self.signals_logger.setLevel(logging.INFO)\n        signals_handler = RotatingFileHandler(\n            log_dir / 'signals.log',\n            maxBytes=10 * 1024 * 1024,\n            backupCount=10\n        )\n        signals_handler.setFormatter(logging.Formatter(\n            '%(asctime)s - %(message)s'\n        ))\n        self.signals_logger.addHandler(signals_handler)\n        \n        # Errors logger\n        self.error_logger = logging.getLogger('stockpulse.errors')\n        self.error_logger.setLevel(logging.ERROR)\n        error_handler = RotatingFileHandler(\n            log_dir / 'errors.log',\n            maxBytes=5 * 1024 * 1024,\n            backupCount=5\n        )\n        error_handler.setFormatter(logging.Formatter(\n            '%(asctime)s - %(levelname)s - %(funcName)s:%(lineno)d - %(message)s\\n%(exc_info)s'\n        ))\n        self.error_logger.addHandler(error_handler)\n        \n        # Performance logger\n        self.performance_logger = logging.getLogger('stockpulse.performance')\n        self.performance_logger.setLevel(logging.INFO)\n        perf_handler = RotatingFileHandler(\n            log_dir / 'performance.log',\n            maxBytes=5 * 1024 * 1024,\n            backupCount=3\n        )\n        perf_handler.setFormatter(logging.Formatter(\n            '%(asctime)s - %(message)s'\n        ))\n        self.performance_logger.addHandler(perf_handler)\n    \n    def log_screening_results(self, results: Dict):\n        \"\"\"Log screening results in structured format\"\"\"\n        try:\n            log_entry = {\n                'timestamp': datetime.now().isoformat(),\n                'type': 'screening_results',\n                'data': {\n                    'total_analyzed': results.get('summary', {}).get('total_analyzed', 0),\n                    'passed_all_screens': results.get('summary', {}).get('passed_all_screens', 0),\n                    'top_candidates': len(results.get('top_10_candidates', [])),\n                    'top_stocks': [stock['ticker'] for stock in results.get('top_10_candidates', [])[:5]]\n                }\n            }\n            \n            self.screening_logger.info(json.dumps(log_entry))\n            \n        except Exception as e:\n            self.error_logger.error(f\"Error logging screening results: {e}\", exc_info=True)\n    \n    def log_signal_detection(self, signals: List[Dict]):\n        \"\"\"Log signal detection results\"\"\"\n        try:\n            bullish_signals = [s for s in signals if s.get('primary_signal') == 'BULLISH']\n            bearish_signals = [s for s in signals if s.get('primary_signal') == 'BEARISH']\n            \n            log_entry = {\n                'timestamp': datetime.now().isoformat(),\n                'type': 'signal_detection',\n                'data': {\n                    'total_analyzed': len(signals),\n                    'bullish_signals': len(bullish_signals),\n                    'bearish_signals': len(bearish_signals),\n                    'high_confidence_signals': len([s for s in signals if s.get('primary_confidence', 0) >= 70]),\n                    'top_bullish': [s['ticker'] for s in sorted(bullish_signals, key=lambda x: x.get('primary_confidence', 0), reverse=True)[:3]],\n                    'top_bearish': [s['ticker'] for s in sorted(bearish_signals, key=lambda x: x.get('primary_confidence', 0), reverse=True)[:3]]\n                }\n            }\n            \n            self.signals_logger.info(json.dumps(log_entry))\n            \n        except Exception as e:\n            self.error_logger.error(f\"Error logging signal detection: {e}\", exc_info=True)\n    \n    def log_performance_metrics(self, operation: str, duration: float, details: Dict = None):\n        \"\"\"Log performance metrics\"\"\"\n        try:\n            log_entry = {\n                'timestamp': datetime.now().isoformat(),\n                'operation': operation,\n                'duration_seconds': round(duration, 3),\n                'details': details or {}\n            }\n            \n            self.performance_logger.info(json.dumps(log_entry))\n            \n        except Exception as e:\n            self.error_logger.error(f\"Error logging performance metrics: {e}\", exc_info=True)\n    \n    def log_error(self, error: Exception, context: str = None, additional_data: Dict = None):\n        \"\"\"Log errors with context and stack trace\"\"\"\n        try:\n            error_data = {\n                'timestamp': datetime.now().isoformat(),\n                'error_type': type(error).__name__,\n                'error_message': str(error),\n                'context': context,\n                'additional_data': additional_data,\n                'stack_trace': traceback.format_exc()\n            }\n            \n            self.error_logger.error(json.dumps(error_data, indent=2))\n            \n        except Exception as e:\n            # Fallback logging\n            logging.error(f\"Error in error logging: {e}\")\n            logging.error(f\"Original error: {error}\")\n    \n    def send_email_notification(self, subject: str, message: str, recipients: List[str] = None, attachment_data: Dict = None):\n        \"\"\"Send email notification\"\"\"\n        if not self.config['smtp_username'] or not self.config['smtp_password']:\n            self.logger.warning(\"Email credentials not configured\")\n            return False\n        \n        try:\n            recipients = recipients or [self.config['notification_email']]\n            if not recipients or not any(recipients):\n                self.logger.warning(\"No email recipients configured\")\n                return False\n            \n            msg = MIMEMultipart()\n            msg['From'] = self.config['smtp_username']\n            msg['To'] = ', '.join(recipients)\n            msg['Subject'] = subject\n            \n            # Add message body\n            msg.attach(MIMEText(message, 'plain'))\n            \n            # Add attachment if provided\n            if attachment_data:\n                for filename, data in attachment_data.items():\n                    part = MIMEBase('application', 'octet-stream')\n                    part.set_payload(data)\n                    encoders.encode_base64(part)\n                    part.add_header(\n                        'Content-Disposition',\n                        f'attachment; filename= {filename}'\n                    )\n                    msg.attach(part)\n            \n            # Send email\n            with smtplib.SMTP(self.config['smtp_server'], self.config['smtp_port']) as server:\n                server.starttls()\n                server.login(self.config['smtp_username'], self.config['smtp_password'])\n                server.send_message(msg)\n            \n            self.logger.info(f\"Email sent successfully to {recipients}\")\n            self._log_notification('email', subject, recipients)\n            return True\n            \n        except Exception as e:\n            self.log_error(e, \"email_notification\", {'subject': subject, 'recipients': recipients})\n            return False\n    \n    def send_slack_notification(self, message: str, channel: str = None, username: str = None, emoji: str = ':chart_with_upwards_trend:'):\n        \"\"\"Send Slack notification\"\"\"\n        if not self.config['slack_webhook']:\n            self.logger.warning(\"Slack webhook not configured\")\n            return False\n        \n        try:\n            payload = {\n                'text': message,\n                'channel': channel or self.config['slack_channel'],\n                'username': username or self.config['slack_username'],\n                'icon_emoji': emoji\n            }\n            \n            response = requests.post(\n                self.config['slack_webhook'],\n                json=payload,\n                timeout=10\n            )\n            \n            if response.status_code == 200:\n                self.logger.info(\"Slack notification sent successfully\")\n                self._log_notification('slack', message[:50], [channel or self.config['slack_channel']])\n                return True\n            else:\n                self.logger.error(f\"Slack notification failed: {response.status_code} - {response.text}\")\n                return False\n                \n        except Exception as e:\n            self.log_error(e, \"slack_notification\", {'message': message[:100]})\n            return False\n    \n    def send_discord_notification(self, message: str, username: str = None):\n        \"\"\"Send Discord notification\"\"\"\n        if not self.config['discord_webhook']:\n            self.logger.warning(\"Discord webhook not configured\")\n            return False\n        \n        try:\n            payload = {\n                'content': message,\n                'username': username or self.config['discord_username']\n            }\n            \n            response = requests.post(\n                self.config['discord_webhook'],\n                json=payload,\n                timeout=10\n            )\n            \n            if response.status_code == 204:\n                self.logger.info(\"Discord notification sent successfully\")\n                self._log_notification('discord', message[:50], ['discord_channel'])\n                return True\n            else:\n                self.logger.error(f\"Discord notification failed: {response.status_code} - {response.text}\")\n                return False\n                \n        except Exception as e:\n            self.log_error(e, \"discord_notification\", {'message': message[:100]})\n            return False\n    \n    def send_telegram_notification(self, message: str):\n        \"\"\"Send Telegram notification\"\"\"\n        if not self.config['telegram_bot_token'] or not self.config['telegram_chat_id']:\n            self.logger.warning(\"Telegram configuration not complete\")\n            return False\n        \n        try:\n            url = f\"https://api.telegram.org/bot{self.config['telegram_bot_token']}/sendMessage\"\n            payload = {\n                'chat_id': self.config['telegram_chat_id'],\n                'text': message,\n                'parse_mode': 'Markdown'\n            }\n            \n            response = requests.post(url, json=payload, timeout=10)\n            \n            if response.status_code == 200:\n                self.logger.info(\"Telegram notification sent successfully\")\n                self._log_notification('telegram', message[:50], [self.config['telegram_chat_id']])\n                return True\n            else:\n                self.logger.error(f\"Telegram notification failed: {response.status_code} - {response.text}\")\n                return False\n                \n        except Exception as e:\n            self.log_error(e, \"telegram_notification\", {'message': message[:100]})\n            return False\n    \n    def send_multi_channel_notification(self, subject: str, message: str, channels: List[str] = None):\n        \"\"\"Send notification to multiple channels\"\"\"\n        channels = channels or ['email', 'slack']\n        results = {}\n        \n        if 'email' in channels:\n            results['email'] = self.send_email_notification(subject, message)\n        \n        if 'slack' in channels:\n            results['slack'] = self.send_slack_notification(f\"*{subject}*\\n{message}\")\n        \n        if 'discord' in channels:\n            results['discord'] = self.send_discord_notification(f\"**{subject}**\\n{message}\")\n        \n        if 'telegram' in channels:\n            results['telegram'] = self.send_telegram_notification(f\"*{subject}*\\n{message}\")\n        \n        return results\n    \n    def _log_notification(self, channel: str, message_preview: str, recipients: List[str]):\n        \"\"\"Log notification history\"\"\"\n        notification_record = {\n            'timestamp': datetime.now().isoformat(),\n            'channel': channel,\n            'message_preview': message_preview,\n            'recipients': recipients,\n            'success': True\n        }\n        \n        self.notification_history.append(notification_record)\n        \n        # Keep only last 100 notifications in memory\n        if len(self.notification_history) > 100:\n            self.notification_history = self.notification_history[-100:]\n    \n    def send_daily_summary(self, screening_results: Dict, signal_results: Dict):\n        \"\"\"Send daily summary notification\"\"\"\n        try:\n            # Generate summary message\n            summary = self._generate_daily_summary(screening_results, signal_results)\n            \n            subject = f\"StockPulse Daily Summary - {datetime.now().strftime('%Y-%m-%d')}\"\n            \n            # Send to configured channels\n            self.send_multi_channel_notification(subject, summary['message'])\n            \n            # Log the summary\n            self.logger.info(f\"Daily summary sent: {summary['stats']}\")\n            \n        except Exception as e:\n            self.log_error(e, \"daily_summary_notification\")\n    \n    def send_alert_notification(self, alert_type: str, ticker: str, signal_data: Dict):\n        \"\"\"Send immediate alert for high-confidence signals\"\"\"\n        try:\n            if signal_data.get('primary_confidence', 0) < 80:\n                return  # Only send alerts for very high confidence signals\n            \n            alert_message = self._generate_alert_message(alert_type, ticker, signal_data)\n            \n            subject = f\"ðŸš¨ StockPulse Alert: {alert_type.upper()} signal for {ticker}\"\n            \n            # Send urgent notification\n            results = self.send_multi_channel_notification(subject, alert_message, ['slack', 'telegram'])\n            \n            self.logger.info(f\"Alert sent for {ticker}: {alert_type} - {signal_data.get('primary_confidence')}% confidence\")\n            \n        except Exception as e:\n            self.log_error(e, \"alert_notification\", {'ticker': ticker, 'alert_type': alert_type})\n    \n    def _generate_daily_summary(self, screening_results: Dict, signal_results: Dict) -> Dict:\n        \"\"\"Generate daily summary message\"\"\"\n        stats = {\n            'total_screened': len(screening_results.get('all_results', [])),\n            'passed_screening': len([r for r in screening_results.get('all_results', []) if r.get('overall_pass')]),\n            'total_signals': len(signal_results.get('all_results', [])),\n            'bullish_signals': len([r for r in signal_results.get('all_results', []) if r.get('primary_signal') == 'BULLISH']),\n            'bearish_signals': len([r for r in signal_results.get('all_results', []) if r.get('primary_signal') == 'BEARISH']),\n            'high_confidence': len([r for r in signal_results.get('all_results', []) if r.get('primary_confidence', 0) >= 70])\n        }\n        \n        message = f\"\"\"\nðŸ“Š **StockPulse Daily Summary - {datetime.now().strftime('%Y-%m-%d')}**\n\nðŸ” **Screening Results:**\nâ€¢ Total Stocks Analyzed: {stats['total_screened']}\nâ€¢ Passed All Screens: {stats['passed_screening']}\n\nðŸ“ˆ **Signal Detection:**\nâ€¢ Total Signals Generated: {stats['total_signals']}\nâ€¢ Bullish Signals: {stats['bullish_signals']}\nâ€¢ Bearish Signals: {stats['bearish_signals']}\nâ€¢ High Confidence (â‰¥70%): {stats['high_confidence']}\n\nðŸŽ¯ **Top Signals:**\n\"\"\"\n        \n        # Add top signals\n        top_signals = sorted(\n            [r for r in signal_results.get('all_results', []) if r.get('primary_confidence', 0) >= 60],\n            key=lambda x: x.get('primary_confidence', 0),\n            reverse=True\n        )[:5]\n        \n        for signal in top_signals:\n            direction = \"ðŸŸ¢\" if signal['primary_signal'] == 'BULLISH' else \"ðŸ”´\"\n            message += f\"{direction} {signal['ticker']} - {signal['primary_confidence']}% confidence\\n\"\n        \n        return {'message': message, 'stats': stats}\n    \n    def _generate_alert_message(self, alert_type: str, ticker: str, signal_data: Dict) -> str:\n        \"\"\"Generate alert message for high-confidence signals\"\"\"\n        direction = \"ðŸŸ¢ BULLISH\" if alert_type.lower() == 'bullish' else \"ðŸ”´ BEARISH\"\n        \n        message = f\"\"\"\nðŸš¨ **HIGH CONFIDENCE SIGNAL ALERT**\n\n{direction} Signal Detected!\n\nðŸ“Š **Details:**\nâ€¢ Ticker: {ticker}\nâ€¢ Signal Type: {signal_data.get('primary_signal')}\nâ€¢ Confidence: {signal_data.get('primary_confidence')}%\nâ€¢ Current Price: ${signal_data.get('technical_data', {}).get('current_price', 'N/A')}\n\nðŸŽ¯ **Top Reasons:**\n\"\"\"\n        \n        for reason in signal_data.get('primary_reasons', [])[:3]:\n            message += f\"â€¢ {reason}\\n\"\n        \n        message += f\"\\nâ° Alert Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\"\n        \n        return message\n    \n    def get_notification_history(self, days: int = 7) -> List[Dict]:\n        \"\"\"Get notification history for the specified number of days\"\"\"\n        cutoff_date = datetime.now() - timedelta(days=days)\n        \n        return [\n            record for record in self.notification_history\n            if datetime.fromisoformat(record['timestamp']) >= cutoff_date\n        ]\n    \n    def cleanup_old_logs(self):\n        \"\"\"Clean up old log files\"\"\"\n        try:\n            log_dir = Path('logs')\n            cutoff_date = datetime.now() - timedelta(days=self.config['log_retention_days'])\n            \n            for log_file in log_dir.glob('*.log*'):\n                if log_file.stat().st_mtime < cutoff_date.timestamp():\n                    log_file.unlink()\n                    self.logger.info(f\"Deleted old log file: {log_file}\")\n                    \n        except Exception as e:\n            self.log_error(e, \"log_cleanup\")\n\n\ndef main():\n    \"\"\"Test the notification and logging system\"\"\"\n    logger_system = NotificationLogger()\n    \n    # Test logging\n    logger_system.logger.info(\"Testing notification and logging system\")\n    \n    # Test performance logging\n    import time\n    start_time = time.time()\n    time.sleep(1)  # Simulate operation\n    duration = time.time() - start_time\n    logger_system.log_performance_metrics('test_operation', duration, {'test': True})\n    \n    # Test error logging\n    try:\n        raise ValueError(\"Test error\")\n    except Exception as e:\n        logger_system.log_error(e, \"testing_error_logging\", {'test_data': 'example'})\n    \n    # Test notifications (will only work if configured)\n    test_message = \"Test notification from StockPulse system\"\n    results = logger_system.send_multi_channel_notification(\n        \"Test Notification\",\n        test_message,\n        ['slack']  # Only test Slack to avoid spam\n    )\n    \n    print(f\"Notification results: {results}\")\n    print(f\"Notification history: {len(logger_system.notification_history)} records\")\n\n\nif __name__ == \"__main__\":\n    main()